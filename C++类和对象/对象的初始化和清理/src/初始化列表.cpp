// #include <iostream>
// using namespace std;

// // 初始化列表
// // 语法: 类名(形参列表):属性1(值),属性2(值)……{}
// //  1，以下情况必须在构造函数时写成初始化列表形式：
// //      1）类成员中存在常量，如 const int a;因为常量只能初始化不能赋值
// //      2）类成员中存在引用，同样的只能初始化不能赋值
// //      3）类成员的基类或成员类没有定义默认构造函数（注意，只要显示定义了类的构造函数，则编译器不再提供默认构造函数。如果没有定义构造函数，则编译器会提供默认构造函数）
// //  2，另外，建议使用初始化列表而不是在构造函数中赋值，原因在于可以提高效率。
// //     假如类成员的基类或成员类都定义了默认构造函数（如存在string类型的类成员），则在初始化时会调用他们的默认构造函数，但如果在构造函数中又对sting成员进行了赋值，则相当于又进行了一次string的拷贝构造。相反，如果放在初始化列表中则只需要调用一次string类的初始化即可。
//  class Person
// {
// public:
//     //传统的赋值
//     // Person(int a,int b,int c)
//     // {
//     //    cout << "传统赋值形式赋值的构造函数调用" << endl;
//     //     m_A = a;
//     //     m_B = b;
//     //     m_C = c;
//     // }
//     Person(int a,int b,int c):m_A(a),m_B(b),m_C(c)
//     {
//         cout << "初始化列表形式赋值的构造函数调用" << endl;
//     }
//     int m_A;
//     int m_B;
//     int m_C;
// };

// void test()
// {
//     Person p(10,20,30);
//     cout << "m_A的值：" << p.m_A << endl;
//     cout << "m_B的值：" << p.m_B << endl;
//     cout << "m_C的值：" << p.m_C << endl;
// }
// int main()
// {
//     test();
//     return 0;
// }